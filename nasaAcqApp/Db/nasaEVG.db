#
# Global acquisition control.
# Fanned out by the event generator.
# Hardwire the first node to be the event generator.
#
record(bo, "$(P)ACQ:enable") {
    field(DESC, "Enable/disable data acquisition")
    field(DTYP, "PSC Single U32")
    field(OUT,  "@$(PORT) 16951 10")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

record(mbbo, "$(P)ACQ:rate") {
    field(DESC, "Set acquisition speed")
    field(ZRVL, "1")
    field(ZRST, "250 kHz")
    field(ONVL, "5")
    field(ONST, "50 kHz")
    field(TWVL, "25")
    field(TWST, "10 kHz")
    field(THVL, "50")
    field(THST, "5 kHz")
    field(FRVL, "250")
    field(FRST, "1 kHz")
    field(VAL,  "0")
    field(FLNK, "$(P)ACQ:rateLO_")
}
# We want the per-FPGA records to process each time the mbbo above processes.
# The MBBO record, unfortunately, does not have an MDEL field, so we have to
# fake it here with this longout.  The per-FPGA records monitor this longout.
record(longout, "$(P)ACQ:rateLO_") {
    field(DESC, "Send monitors to per-FPGA records")
    field(DOL,  "$(P)ACQ:rate.RVAL")
    field(OMSL, "closed_loop")
    field(MDEL, "-1")
}
record(fanout, "$(P)ACQ:rate_") {
    field(DESC, "Update acquisition speed on (re)connect")
    field(LNK1, "$(P)ACQ:rate")
    field(SCAN, "Event")
    field(EVNT, "RECON")
}

#
# Reset all FPGAs
# The actual I/O is done by the per-FPGA records
#
record(longout, "$(P)FPGA:reboot") {
    field(DESC, "Write 1, 100, 10000 to reboot FPGA")
}
