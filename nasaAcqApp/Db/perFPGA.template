
record(longout, "$(P)$(R)FPGA:clrPowerUp_") {
    field(DESC, "Clear FPGA power-up status")
    field(DTYP, "PSC Single I32")
    field(OUT,  "@$(PORT) 16951 1")
}

#
# Trigger a build date readback
#
record(bo, "$(P)$(R)buildDates_") {
    field(DESC, "Trigger build dates readback")
    field(DTYP, "PSC Single U32")
    field(OUT,  "@$(PORT) 16953 0")
    field(ZNAM, "Readback")
    field(ONAM, "Readback")
    field(FLNK, "$(P)$(R)send_")
}

#
# Trigger a system monitor readback
#
record(bo, "$(P)$(R)sysmonTrig_") {
    field(DESC, "Trigger system monitor readback")
    field(DTYP, "PSC Single U32")
    field(OUT,  "@$(PORT) 16952 0")
    field(ZNAM, "Readback")
    field(ONAM, "Readback")
    field(SCAN, "2 second")
    field(FLNK, "$(P)$(R)send_")
}

# use sysmon RX to detect comm. fault
record(longin, "$(P)$(R)sysmonRB_") {
    field(SCAN, "I/O Intr")
    field(DTYP, "PSC Reg")
    field(INP , "@$(PORT) 16952 0")
    field(FLNK, "$(P)$(R)sysmonRst_")
}
record(longout, "$(P)$(R)sysmonRst_") {
    field(OUT, "$(P)$(R)sysmonAge.A NPP")
    field(VAL, "0")
}
record(calc, "$(P)$(R)sysmonAge") {
    field(PINI, "YES") # initialize alarm state
    field(SCAN, ".5 second")
    field(INPA, "99") # initially in timeout
    field(INPB, "0.5") # SCAN period
    field(CALC, "A:=A+B;A")
    field(EGU, "s")
    field(PREC, "1")
    field(HIGH, "4")
    field(HSV , "MAJOR")
    field(FLNK, "$(P)$(R)ondis") # ensure timeout always noted
}

record(mbbi, "$(P)$(R)conn") {
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(ZRST, "Timeout") # no comms
    field(ONST, "Normal")  # well, normal operation
    field(TWST, "Init")    # (re)pushing settings
    field(ZRSV, "MAJOR")
    field(ONSV, "NO_ALARM")
    field(TWSV, "MINOR")
}

record(calcout, "$(P)$(R)ondis") {
    field(INPA, "$(P)$(R)sysmonAge.SEVR")
    field(CALC, "A==0")
    field(OOPT, "When Non-zero") # ensure timeout always noted (eg. Timeout during Init)
    field(DOPT, "Use OCAL")
    field(OCAL, "0") # set state to Timeout
    field(OUT , "$(P)$(R)conn PP")
}

record(calcout, "$(P)$(R)onconn") {
    field(INPA, "$(P)$(R)sysmonAge.SEVR CP") # only on edge
    field(CALC, "A<2")
    field(OOPT, "Transition To Zero") # alarm -> ok
    field(OUT , "$(P)$(R)reconn:c1.PROC")
    field(TPRO, "1")
}
# push per-FPGA
record(seq, "$(P)$(R)reconn:c1") {
    field(TPRO, "1")
    field(DOL0, "2") # starting Init
    field(LNK0, "$(P)$(R)conn PP")
    # first ensure that acquisition is disabled.  Broken link except with EVG node
    field(DOL1, "0")
    field(LNK1, "$(P)ACQ:enable PP")
    field(DLY1, "0.01") # TODO: hack.  device socket buffer too small to handle this blizzard...
    # read-back build date
    field(LNK2, "$(P)$(R)buildDates_.PROC PP")
    field(DLY2, "0.01")
    # push decimator
    field(LNK3, "$(P)$(R)ACQ:downsample_.PROC PP") # also pushs AA filter coeff.
    field(DLY3, "0.01")
    field(LNKF, "$(P)$(R)reconn:c2.PROC")
    field(DLYF, "0.1")
}
# push per-channel
record(seq, "$(P)$(R)reconn:c2") {
    field(TPRO, "1")
    field(LNK0, "$(P)$(R)reconn:01.PROC")
    field(DLY0, "0.1")
    field(LNK1, "$(P)$(R)reconn:02.PROC")
    field(DLY1, "0.1")
    field(LNK2, "$(P)$(R)reconn:03.PROC")
    field(DLY2, "0.1")
    field(LNK3, "$(P)$(R)reconn:04.PROC")
    field(DLY3, "0.1")
    field(LNK4, "$(P)$(R)reconn:05.PROC")
    field(DLY4, "0.1")
    field(LNK5, "$(P)$(R)reconn:06.PROC")
    field(DLY5, "0.1")
    field(LNK6, "$(P)$(R)reconn:07.PROC")
    field(DLY6, "0.1")
    field(LNK7, "$(P)$(R)reconn:08.PROC")
    field(DLY7, "0.1")
    field(LNK8, "$(P)$(R)reconn:09.PROC")
    field(DLY8, "0.1")
    field(LNK9, "$(P)$(R)reconn:10.PROC")
    field(DLY9, "0.1")
    field(LNKA, "$(P)$(R)reconn:11.PROC")
    field(DLYA, "0.1")
    field(LNKB, "$(P)$(R)reconn:12.PROC")
    field(DLYB, "0.1")
    field(LNKC, "$(P)$(R)reconn:13.PROC")
    field(DLYC, "0.1")
    field(LNKD, "$(P)$(R)reconn:14.PROC")
    field(DLYD, "0.1")
    field(LNKE, "$(P)$(R)reconn:15.PROC")
    field(DLYE, "0.1")
    field(LNKF, "$(P)$(R)reconn:c3.PROC")
    field(DLYF, "0.1")
}
record(seq, "$(P)$(R)reconn:c3") {
    field(TPRO, "1")
    field(LNK0, "$(P)$(R)reconn:16.PROC")
    field(DLY0, "0.1")
    field(LNK1, "$(P)$(R)reconn:17.PROC")
    field(DLY1, "0.1")
    field(LNK2, "$(P)$(R)reconn:18.PROC")
    field(DLY2, "0.1")
    field(LNK3, "$(P)$(R)reconn:19.PROC")
    field(DLY3, "0.1")
    field(LNK4, "$(P)$(R)reconn:20.PROC")
    field(DLY4, "0.1")
    field(LNK5, "$(P)$(R)reconn:21.PROC")
    field(DLY5, "0.1")
    field(LNK6, "$(P)$(R)reconn:22.PROC")
    field(DLY6, "0.1")
    field(LNK7, "$(P)$(R)reconn:23.PROC")
    field(DLY7, "0.1")
    field(LNK8, "$(P)$(R)reconn:24.PROC")
    field(DLY8, "0.1")
    field(LNK9, "$(P)$(R)reconn:25.PROC")
    field(DLY9, "0.1")
    field(LNKA, "$(P)$(R)reconn:26.PROC")
    field(DLYA, "0.1")
    field(LNKB, "$(P)$(R)reconn:27.PROC")
    field(DLYB, "0.1")
    field(LNKC, "$(P)$(R)reconn:28.PROC")
    field(DLYC, "0.1")
    field(LNKD, "$(P)$(R)reconn:29.PROC")
    field(DLYD, "0.1")
    field(LNKE, "$(P)$(R)reconn:30.PROC")
    field(DLYE, "0.1")
    field(LNKF, "$(P)$(R)reconn:c4.PROC")
    field(DLYF, "0.1")
}
record(seq, "$(P)$(R)reconn:c4") {
    field(LNK0, "$(P)$(R)reconn:31.PROC")
    field(DLY0, "0.1")
    field(LNK1, "$(P)$(R)reconn:32.PROC")
    field(DLY1, "0.1")
    # done...
    field(DOLF, "1") # Return to Normal
    field(LNKF, "$(P)$(R)conn PP")
}

#
# Send all pending output packets
#
record(bo, "$(P)$(R)send_") {
    field(DTYP, "PSC Ctrl Send All")
    field(OUT , "@$(PORT)")
    field(ZNAM, "Send")
    field(ONAM, "Send")
}

#
# Downsampling factor
#
record(longout, "$(P)$(R)ACQ:downsample_") {
    field(DESC, "Set downsampling factor")
    field(DTYP, "PSC Single I32")
    field(OUT,  "@$(PORT) 16951 20")
    field(OMSL, "closed_loop")
    field(DOL , "$(EVG)ACQ:rate.RVAL CPP")
    field(LOPR, "1")
    field(HOPR, "1023")
    field(DRVL, "1")
    field(DRVH, "1023")
    field(FLNK, "$(P)$(R)ACQ:alphaCMP_")
}

#
# Compute downsampling filter alpha (first order IIR lowpass)
# Place cutoff frequency at 0.4 of downsample rate
#
record(calc, "$(P)$(R)ACQ:alphaCMP_") {
    field(DESC, "Compute downsampling filter alpha")
    field(INPA, "$(P)$(R)ACQ:downsample_")
    field(INPB, "-2.513274122871834") # -2 * PI * 0.4
    field(CALC, "(A<=1)?1:(1-EXP(B/A))")
    field(FLNK, "$(P)$(R)ACQ:alpha_")
}

#
# Send downsampling filter alpha (first order IIR lowpass)
#
record(ao, "$(P)$(R)ACQ:alpha_") {
    field(DESC, "Downsampling filter alpha")
    field(DTYP, "PSC Single I32")
    field(OUT,  "@$(PORT) 16951 21")
    field(OMSL, "closed_loop")
    field(DOL,  "$(P)$(R)ACQ:alphaCMP_")
    field(LINR, "SLOPE")
    field(ESLO, "7.62939453125e-06")  # 1 / (2^17)
    field(LOPR, "0.0001")
    field(HOPR, "1")
    field(DRVL, "0.0001")
    field(DRVH, "1")
    field(FLNK, "$(P)$(R)send_")
}

#
# Reboot FPGA
# Driven diretly by client
#
record(longout, "$(P)$(R)FPGA:reboot") {
    field(DESC, "Write 1, 100, 10000 to reboot FPGA")
    field(DTYP, "PSC Single I32")
    field(OUT,  "@$(PORT) 16951 0")
    field(FLNK, "$(P)$(R)send_")
}

#
# Reset FPGA -- driven from common reboot record
#
record(longout, "$(P)$(R)FPGA:reboot_") {
    field(DESC, "Write 1, 100, 10000 to reboot FPGA")
    field(DTYP, "PSC Single I32")
    field(OUT,  "@$(PORT) 16951 0")
    field(OMSL, "closed_loop")
    field(DOL , "$(P)FPGA:reboot CPP")
}
